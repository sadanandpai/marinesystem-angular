/**
 * @license Angular v9.1.1
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */

import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { ModuleWithProviders } from '@angular/core';
import { Observable } from 'rxjs';

/**
 * @publicApi
 */
import * as ɵngcc0 from '@angular/core';
export declare class ServiceWorkerModule {
    /**
     * Register the given Angular Service Worker script.
     *
     * If `enabled` is set to `false` in the given options, the module will behave as if service
     * workers are not supported by the browser, and the service worker will not be registered.
     */
    static register(script: string, opts?: SwRegistrationOptions): ModuleWithProviders<ServiceWorkerModule>;
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<ServiceWorkerModule, never, never, never>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<ServiceWorkerModule>;
}

/**
 * Subscribe and listen to
 * [Web Push Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)
 * through Angular Service Worker.
 *
 * @usageNotes
 *
 * You can inject a `SwPush` instance into any component or service
 * as a dependency.
 *
 * <code-example path="service-worker/push/module.ts" region="inject-sw-push" header="app.component.ts"></code-example>
 *
 * To subscribe, call `SwPush.requestSubscription()`, which asks the user for permission.
 * The call returns a `Promise` with a new
 * [`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)
 * instance.
 *
 * <code-example path="service-worker/push/module.ts" region="subscribe-to-push" header="app.component.ts"></code-example>
 *
 * A request is rejected if the user denies permission, or if the browser
 * blocks or does not support the Push API or ServiceWorkers.
 * Check `SwPush.isEnabled` to confirm status.
 *
 * Invoke Push Notifications by pushing a message with the following payload.
 *
 * ```ts
 * {
 *   "notification": {
 *     "actions": NotificationAction[],
 *     "badge": USVString
 *     "body": DOMString,
 *     "data": any,
 *     "dir": "auto"|"ltr"|"rtl",
 *     "icon": USVString,
 *     "image": USVString,
 *     "lang": DOMString,
 *     "renotify": boolean,
 *     "requireInteraction": boolean,
 *     "silent": boolean,
 *     "tag": DOMString,
 *     "timestamp": DOMTimeStamp,
 *     "title": DOMString,
 *     "vibrate": number[]
 *   }
 * }
 * ```
 *
 * Only `title` is required. See `Notification`
 * [instance properties](https://developer.mozilla.org/en-US/docs/Web/API/Notification#Instance_properties).
 *
 * While the subscription is active, Service Worker listens for
 * [PushEvent](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)
 * occurrences and creates
 * [Notification](https://developer.mozilla.org/en-US/docs/Web/API/Notification)
 * instances in response.
 *
 * Unsubscribe using `SwPush.unsubscribe()`.
 *
 * An application can subscribe to `SwPush.notificationClicks` observable to be notified when a user
 * clicks on a notification. For example:
 *
 * <code-example path="service-worker/push/module.ts" region="subscribe-to-notification-clicks" header="app.component.ts"></code-example>
 *
 * @see [Push Notifications](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)
 * @see [Angular Push Notifications](https://blog.angular-university.io/angular-push-notifications/)
 * @see [MDN: Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)
 * @see [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)
 * @see [MDN: Web Push API Notifications best practices](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)
 *
 * @publicApi
 */
export declare class SwPush {
    private sw;
    /**
     * Emits the payloads of the received push notification messages.
     */
    readonly messages: Observable<object>;
    /**
     * Emits the payloads of the received push notification messages as well as the action the user
     * interacted with. If no action was used the `action` property contains an empty string `''`.
     *
     * Note that the `notification` property does **not** contain a
     * [Notification][Mozilla Notification] object but rather a
     * [NotificationOptions](https://notifications.spec.whatwg.org/#dictdef-notificationoptions)
     * object that also includes the `title` of the [Notification][Mozilla Notification] object.
     *
     * [Mozilla Notification]: https://developer.mozilla.org/en-US/docs/Web/API/Notification
     */
    readonly notificationClicks: Observable<{
        action: string;
        notification: NotificationOptions & {
            title: string;
        };
    }>;
    /**
     * Emits the currently active
     * [PushSubscription](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)
     * associated to the Service Worker registration or `null` if there is no subscription.
     */
    readonly subscription: Observable<PushSubscription | null>;
    /**
     * True if the Service Worker is enabled (supported by the browser and enabled via
     * `ServiceWorkerModule`).
     */
    get isEnabled(): boolean;
    private pushManager;
    private subscriptionChanges;
    constructor(sw: ɵangular_packages_service_worker_service_worker_a);
    /**
     * Subscribes to Web Push Notifications,
     * after requesting and receiving user permission.
     *
     * @param options An object containing the `serverPublicKey` string.
     * @returns A Promise that resolves to the new subscription object.
     */
    requestSubscription(options: {
        serverPublicKey: string;
    }): Promise<PushSubscription>;
    /**
     * Unsubscribes from Service Worker push notifications.
     *
     * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no
     *          active subscription or the unsubscribe operation fails.
     */
    unsubscribe(): Promise<void>;
    private decodeBase64;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SwPush, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<SwPush>;
}

/**
 * Token that can be used to provide options for `ServiceWorkerModule` outside of
 * `ServiceWorkerModule.register()`.
 *
 * You can use this token to define a provider that generates the registration options at runtime,
 * for example via a function call:
 *
 * {@example service-worker/registration-options/module.ts region="registration-options"
 *     header="app.module.ts"}
 *
 * @publicApi
 */
export declare abstract class SwRegistrationOptions {
    /**
     * Whether the ServiceWorker will be registered and the related services (such as `SwPush` and
     * `SwUpdate`) will attempt to communicate and interact with it.
     *
     * Default: true
     */
    enabled?: boolean;
    /**
     * A URL that defines the ServiceWorker's registration scope; that is, what range of URLs it can
     * control. It will be used when calling
     * [ServiceWorkerContainer#register()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).
     */
    scope?: string;
    /**
     * Defines the ServiceWorker registration strategy, which determines when it will be registered
     * with the browser.
     *
     * The default behavior of registering once the application stabilizes (i.e. as soon as there are
     * no pending micro- and macro-tasks), is designed register the ServiceWorker as soon as possible
     * but without affecting the application's first time load.
     *
     * Still, there might be cases where you want more control over when the ServiceWorker is
     * registered (e.g. there might be a long-running timeout or polling interval, preventing the app
     * to stabilize). The available option are:
     *
     * - `registerWhenStable`: Register as soon as the application stabilizes (no pending
     *      micro-/macro-tasks).
     * - `registerImmediately`: Register immediately.
     * - `registerWithDelay:<timeout>`: Register with a delay of `<timeout>` milliseconds. For
     *     example, use `registerWithDelay:5000` to register the ServiceWorker after 5 seconds. If
     *     `<timeout>` is omitted, is defaults to `0`, which will register the ServiceWorker as soon
     *     as possible but still asynchronously, once all pending micro-tasks are completed.
     * - An [Observable](guide/observables) factory function: A function that returns an `Observable`.
     *     The function will be used at runtime to obtain and subscribe to the `Observable` and the
     *     ServiceWorker will be registered as soon as the first value is emitted.
     *
     * Default: 'registerWhenStable'
     */
    registrationStrategy?: string | (() => Observable<unknown>);
}

/**
 * Subscribe to update notifications from the Service Worker, trigger update
 * checks, and forcibly activate updates.
 *
 * @publicApi
 */
export declare class SwUpdate {
    private sw;
    /**
     * Emits an `UpdateAvailableEvent` event whenever a new app version is available.
     */
    readonly available: Observable<UpdateAvailableEvent>;
    /**
     * Emits an `UpdateActivatedEvent` event whenever the app has been updated to a new version.
     */
    readonly activated: Observable<UpdateActivatedEvent>;
    /**
     * True if the Service Worker is enabled (supported by the browser and enabled via
     * `ServiceWorkerModule`).
     */
    get isEnabled(): boolean;
    constructor(sw: ɵangular_packages_service_worker_service_worker_a);
    checkForUpdate(): Promise<void>;
    activateUpdate(): Promise<void>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SwUpdate, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<SwUpdate>;
}

declare interface TypedEvent {
    type: string;
}

/**
 * An event emitted when a new version of the app has been downloaded and activated.
 *
 * @publicApi
 */
export declare interface UpdateActivatedEvent {
    type: 'UPDATE_ACTIVATED';
    previous?: {
        hash: string;
        appData?: Object;
    };
    current: {
        hash: string;
        appData?: Object;
    };
}

/**
 * An event emitted when a new version of the app is available.
 *
 * @publicApi
 */
export declare interface UpdateAvailableEvent {
    type: 'UPDATE_AVAILABLE';
    current: {
        hash: string;
        appData?: Object;
    };
    available: {
        hash: string;
        appData?: Object;
    };
}

/**
 * @publicApi
 */
export declare class ɵangular_packages_service_worker_service_worker_a {
    private serviceWorker;
    readonly worker: Observable<ServiceWorker>;
    readonly registration: Observable<ServiceWorkerRegistration>;
    readonly events: Observable<TypedEvent>;
    constructor(serviceWorker: ServiceWorkerContainer | undefined);
    postMessage(action: string, payload: Object): Promise<void>;
    postMessageWithStatus(type: string, payload: Object, nonce: number): Promise<void>;
    generateNonce(): number;
    eventsOfType<T extends TypedEvent>(type: T['type']): Observable<T>;
    nextEventOfType<T extends TypedEvent>(type: T['type']): Observable<T>;
    waitForStatus(nonce: number): Promise<void>;
    get isEnabled(): boolean;
}

export declare const ɵangular_packages_service_worker_service_worker_b: InjectionToken<string>;

export declare function ɵangular_packages_service_worker_service_worker_c(injector: Injector, script: string, options: SwRegistrationOptions, platformId: string): Function;

export declare function ɵangular_packages_service_worker_service_worker_d(opts: SwRegistrationOptions, platformId: string): ɵangular_packages_service_worker_service_worker_a;

export { }

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS13b3JrZXIuZC50cyIsInNvdXJjZXMiOlsic2VydmljZS13b3JrZXIuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjkuMS4xXG4gKiAoYykgMjAxMC0yMDIwIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNlcnZpY2VXb3JrZXJNb2R1bGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gQW5ndWxhciBTZXJ2aWNlIFdvcmtlciBzY3JpcHQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYGVuYWJsZWRgIGlzIHNldCB0byBgZmFsc2VgIGluIHRoZSBnaXZlbiBvcHRpb25zLCB0aGUgbW9kdWxlIHdpbGwgYmVoYXZlIGFzIGlmIHNlcnZpY2VcclxuICAgICAqIHdvcmtlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIGFuZCB0aGUgc2VydmljZSB3b3JrZXIgd2lsbCBub3QgYmUgcmVnaXN0ZXJlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlZ2lzdGVyKHNjcmlwdDogc3RyaW5nLCBvcHRzPzogU3dSZWdpc3RyYXRpb25PcHRpb25zKTogTW9kdWxlV2l0aFByb3ZpZGVyczxTZXJ2aWNlV29ya2VyTW9kdWxlPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN1YnNjcmliZSBhbmQgbGlzdGVuIHRvXHJcbiAqIFtXZWIgUHVzaCBOb3RpZmljYXRpb25zXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVzaF9BUEkvQmVzdF9QcmFjdGljZXMpXHJcbiAqIHRocm91Z2ggQW5ndWxhciBTZXJ2aWNlIFdvcmtlci5cclxuICpcclxuICogQHVzYWdlTm90ZXNcclxuICpcclxuICogWW91IGNhbiBpbmplY3QgYSBgU3dQdXNoYCBpbnN0YW5jZSBpbnRvIGFueSBjb21wb25lbnQgb3Igc2VydmljZVxyXG4gKiBhcyBhIGRlcGVuZGVuY3kuXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cInNlcnZpY2Utd29ya2VyL3B1c2gvbW9kdWxlLnRzXCIgcmVnaW9uPVwiaW5qZWN0LXN3LXB1c2hcIiBoZWFkZXI9XCJhcHAuY29tcG9uZW50LnRzXCI+PC9jb2RlLWV4YW1wbGU+XHJcbiAqXHJcbiAqIFRvIHN1YnNjcmliZSwgY2FsbCBgU3dQdXNoLnJlcXVlc3RTdWJzY3JpcHRpb24oKWAsIHdoaWNoIGFza3MgdGhlIHVzZXIgZm9yIHBlcm1pc3Npb24uXHJcbiAqIFRoZSBjYWxsIHJldHVybnMgYSBgUHJvbWlzZWAgd2l0aCBhIG5ld1xyXG4gKiBbYFB1c2hTdWJzY3JpcHRpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVzaFN1YnNjcmlwdGlvbilcclxuICogaW5zdGFuY2UuXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cInNlcnZpY2Utd29ya2VyL3B1c2gvbW9kdWxlLnRzXCIgcmVnaW9uPVwic3Vic2NyaWJlLXRvLXB1c2hcIiBoZWFkZXI9XCJhcHAuY29tcG9uZW50LnRzXCI+PC9jb2RlLWV4YW1wbGU+XHJcbiAqXHJcbiAqIEEgcmVxdWVzdCBpcyByZWplY3RlZCBpZiB0aGUgdXNlciBkZW5pZXMgcGVybWlzc2lvbiwgb3IgaWYgdGhlIGJyb3dzZXJcclxuICogYmxvY2tzIG9yIGRvZXMgbm90IHN1cHBvcnQgdGhlIFB1c2ggQVBJIG9yIFNlcnZpY2VXb3JrZXJzLlxyXG4gKiBDaGVjayBgU3dQdXNoLmlzRW5hYmxlZGAgdG8gY29uZmlybSBzdGF0dXMuXHJcbiAqXHJcbiAqIEludm9rZSBQdXNoIE5vdGlmaWNhdGlvbnMgYnkgcHVzaGluZyBhIG1lc3NhZ2Ugd2l0aCB0aGUgZm9sbG93aW5nIHBheWxvYWQuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIHtcclxuICogICBcIm5vdGlmaWNhdGlvblwiOiB7XHJcbiAqICAgICBcImFjdGlvbnNcIjogTm90aWZpY2F0aW9uQWN0aW9uW10sXHJcbiAqICAgICBcImJhZGdlXCI6IFVTVlN0cmluZ1xyXG4gKiAgICAgXCJib2R5XCI6IERPTVN0cmluZyxcclxuICogICAgIFwiZGF0YVwiOiBhbnksXHJcbiAqICAgICBcImRpclwiOiBcImF1dG9cInxcImx0clwifFwicnRsXCIsXHJcbiAqICAgICBcImljb25cIjogVVNWU3RyaW5nLFxyXG4gKiAgICAgXCJpbWFnZVwiOiBVU1ZTdHJpbmcsXHJcbiAqICAgICBcImxhbmdcIjogRE9NU3RyaW5nLFxyXG4gKiAgICAgXCJyZW5vdGlmeVwiOiBib29sZWFuLFxyXG4gKiAgICAgXCJyZXF1aXJlSW50ZXJhY3Rpb25cIjogYm9vbGVhbixcclxuICogICAgIFwic2lsZW50XCI6IGJvb2xlYW4sXHJcbiAqICAgICBcInRhZ1wiOiBET01TdHJpbmcsXHJcbiAqICAgICBcInRpbWVzdGFtcFwiOiBET01UaW1lU3RhbXAsXHJcbiAqICAgICBcInRpdGxlXCI6IERPTVN0cmluZyxcclxuICogICAgIFwidmlicmF0ZVwiOiBudW1iZXJbXVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogT25seSBgdGl0bGVgIGlzIHJlcXVpcmVkLiBTZWUgYE5vdGlmaWNhdGlvbmBcclxuICogW2luc3RhbmNlIHByb3BlcnRpZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob3RpZmljYXRpb24jSW5zdGFuY2VfcHJvcGVydGllcykuXHJcbiAqXHJcbiAqIFdoaWxlIHRoZSBzdWJzY3JpcHRpb24gaXMgYWN0aXZlLCBTZXJ2aWNlIFdvcmtlciBsaXN0ZW5zIGZvclxyXG4gKiBbUHVzaEV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVzaEV2ZW50KVxyXG4gKiBvY2N1cnJlbmNlcyBhbmQgY3JlYXRlc1xyXG4gKiBbTm90aWZpY2F0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm90aWZpY2F0aW9uKVxyXG4gKiBpbnN0YW5jZXMgaW4gcmVzcG9uc2UuXHJcbiAqXHJcbiAqIFVuc3Vic2NyaWJlIHVzaW5nIGBTd1B1c2gudW5zdWJzY3JpYmUoKWAuXHJcbiAqXHJcbiAqIEFuIGFwcGxpY2F0aW9uIGNhbiBzdWJzY3JpYmUgdG8gYFN3UHVzaC5ub3RpZmljYXRpb25DbGlja3NgIG9ic2VydmFibGUgdG8gYmUgbm90aWZpZWQgd2hlbiBhIHVzZXJcclxuICogY2xpY2tzIG9uIGEgbm90aWZpY2F0aW9uLiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogPGNvZGUtZXhhbXBsZSBwYXRoPVwic2VydmljZS13b3JrZXIvcHVzaC9tb2R1bGUudHNcIiByZWdpb249XCJzdWJzY3JpYmUtdG8tbm90aWZpY2F0aW9uLWNsaWNrc1wiIGhlYWRlcj1cImFwcC5jb21wb25lbnQudHNcIj48L2NvZGUtZXhhbXBsZT5cclxuICpcclxuICogQHNlZSBbUHVzaCBOb3RpZmljYXRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL2NvZGVsYWJzL3B1c2gtbm90aWZpY2F0aW9ucy8pXHJcbiAqIEBzZWUgW0FuZ3VsYXIgUHVzaCBOb3RpZmljYXRpb25zXShodHRwczovL2Jsb2cuYW5ndWxhci11bml2ZXJzaXR5LmlvL2FuZ3VsYXItcHVzaC1ub3RpZmljYXRpb25zLylcclxuICogQHNlZSBbTUROOiBQdXNoIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1c2hfQVBJKVxyXG4gKiBAc2VlIFtNRE46IE5vdGlmaWNhdGlvbnMgQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm90aWZpY2F0aW9uc19BUEkpXHJcbiAqIEBzZWUgW01ETjogV2ViIFB1c2ggQVBJIE5vdGlmaWNhdGlvbnMgYmVzdCBwcmFjdGljZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdXNoX0FQSS9CZXN0X1ByYWN0aWNlcylcclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU3dQdXNoIHtcclxuICAgIHByaXZhdGUgc3c7XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIHRoZSBwYXlsb2FkcyBvZiB0aGUgcmVjZWl2ZWQgcHVzaCBub3RpZmljYXRpb24gbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IG1lc3NhZ2VzOiBPYnNlcnZhYmxlPG9iamVjdD47XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIHRoZSBwYXlsb2FkcyBvZiB0aGUgcmVjZWl2ZWQgcHVzaCBub3RpZmljYXRpb24gbWVzc2FnZXMgYXMgd2VsbCBhcyB0aGUgYWN0aW9uIHRoZSB1c2VyXHJcbiAgICAgKiBpbnRlcmFjdGVkIHdpdGguIElmIG5vIGFjdGlvbiB3YXMgdXNlZCB0aGUgYGFjdGlvbmAgcHJvcGVydHkgY29udGFpbnMgYW4gZW1wdHkgc3RyaW5nIGAnJ2AuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBgbm90aWZpY2F0aW9uYCBwcm9wZXJ0eSBkb2VzICoqbm90KiogY29udGFpbiBhXHJcbiAgICAgKiBbTm90aWZpY2F0aW9uXVtNb3ppbGxhIE5vdGlmaWNhdGlvbl0gb2JqZWN0IGJ1dCByYXRoZXIgYVxyXG4gICAgICogW05vdGlmaWNhdGlvbk9wdGlvbnNdKGh0dHBzOi8vbm90aWZpY2F0aW9ucy5zcGVjLndoYXR3Zy5vcmcvI2RpY3RkZWYtbm90aWZpY2F0aW9ub3B0aW9ucylcclxuICAgICAqIG9iamVjdCB0aGF0IGFsc28gaW5jbHVkZXMgdGhlIGB0aXRsZWAgb2YgdGhlIFtOb3RpZmljYXRpb25dW01vemlsbGEgTm90aWZpY2F0aW9uXSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogW01vemlsbGEgTm90aWZpY2F0aW9uXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vdGlmaWNhdGlvblxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBub3RpZmljYXRpb25DbGlja3M6IE9ic2VydmFibGU8e1xyXG4gICAgICAgIGFjdGlvbjogc3RyaW5nO1xyXG4gICAgICAgIG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uT3B0aW9ucyAmIHtcclxuICAgICAgICAgICAgdGl0bGU6IHN0cmluZztcclxuICAgICAgICB9O1xyXG4gICAgfT47XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIHRoZSBjdXJyZW50bHkgYWN0aXZlXHJcbiAgICAgKiBbUHVzaFN1YnNjcmlwdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1c2hTdWJzY3JpcHRpb24pXHJcbiAgICAgKiBhc3NvY2lhdGVkIHRvIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gb3IgYG51bGxgIGlmIHRoZXJlIGlzIG5vIHN1YnNjcmlwdGlvbi5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgc3Vic2NyaXB0aW9uOiBPYnNlcnZhYmxlPFB1c2hTdWJzY3JpcHRpb24gfCBudWxsPjtcclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgU2VydmljZSBXb3JrZXIgaXMgZW5hYmxlZCAoc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIGFuZCBlbmFibGVkIHZpYVxyXG4gICAgICogYFNlcnZpY2VXb3JrZXJNb2R1bGVgKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBwdXNoTWFuYWdlcjtcclxuICAgIHByaXZhdGUgc3Vic2NyaXB0aW9uQ2hhbmdlcztcclxuICAgIGNvbnN0cnVjdG9yKHN3OiDJtWFuZ3VsYXJfcGFja2FnZXNfc2VydmljZV93b3JrZXJfc2VydmljZV93b3JrZXJfYSk7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gV2ViIFB1c2ggTm90aWZpY2F0aW9ucyxcclxuICAgICAqIGFmdGVyIHJlcXVlc3RpbmcgYW5kIHJlY2VpdmluZyB1c2VyIHBlcm1pc3Npb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzZXJ2ZXJQdWJsaWNLZXlgIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgc3Vic2NyaXB0aW9uIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcmVxdWVzdFN1YnNjcmlwdGlvbihvcHRpb25zOiB7XHJcbiAgICAgICAgc2VydmVyUHVibGljS2V5OiBzdHJpbmc7XHJcbiAgICB9KTogUHJvbWlzZTxQdXNoU3Vic2NyaXB0aW9uPjtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gU2VydmljZSBXb3JrZXIgcHVzaCBub3RpZmljYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBzdWNjZWVkcywgb3IgaXMgcmVqZWN0ZWQgaWYgdGhlcmUgaXMgbm9cclxuICAgICAqICAgICAgICAgIGFjdGl2ZSBzdWJzY3JpcHRpb24gb3IgdGhlIHVuc3Vic2NyaWJlIG9wZXJhdGlvbiBmYWlscy5cclxuICAgICAqL1xyXG4gICAgdW5zdWJzY3JpYmUoKTogUHJvbWlzZTx2b2lkPjtcclxuICAgIHByaXZhdGUgZGVjb2RlQmFzZTY0O1xyXG59XHJcblxyXG4vKipcclxuICogVG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIG9wdGlvbnMgZm9yIGBTZXJ2aWNlV29ya2VyTW9kdWxlYCBvdXRzaWRlIG9mXHJcbiAqIGBTZXJ2aWNlV29ya2VyTW9kdWxlLnJlZ2lzdGVyKClgLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSB0aGlzIHRva2VuIHRvIGRlZmluZSBhIHByb3ZpZGVyIHRoYXQgZ2VuZXJhdGVzIHRoZSByZWdpc3RyYXRpb24gb3B0aW9ucyBhdCBydW50aW1lLFxyXG4gKiBmb3IgZXhhbXBsZSB2aWEgYSBmdW5jdGlvbiBjYWxsOlxyXG4gKlxyXG4gKiB7QGV4YW1wbGUgc2VydmljZS13b3JrZXIvcmVnaXN0cmF0aW9uLW9wdGlvbnMvbW9kdWxlLnRzIHJlZ2lvbj1cInJlZ2lzdHJhdGlvbi1vcHRpb25zXCJcclxuICogICAgIGhlYWRlcj1cImFwcC5tb2R1bGUudHNcIn1cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgU3dSZWdpc3RyYXRpb25PcHRpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgU2VydmljZVdvcmtlciB3aWxsIGJlIHJlZ2lzdGVyZWQgYW5kIHRoZSByZWxhdGVkIHNlcnZpY2VzIChzdWNoIGFzIGBTd1B1c2hgIGFuZFxyXG4gICAgICogYFN3VXBkYXRlYCkgd2lsbCBhdHRlbXB0IHRvIGNvbW11bmljYXRlIGFuZCBpbnRlcmFjdCB3aXRoIGl0LlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQ6IHRydWVcclxuICAgICAqL1xyXG4gICAgZW5hYmxlZD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIEEgVVJMIHRoYXQgZGVmaW5lcyB0aGUgU2VydmljZVdvcmtlcidzIHJlZ2lzdHJhdGlvbiBzY29wZTsgdGhhdCBpcywgd2hhdCByYW5nZSBvZiBVUkxzIGl0IGNhblxyXG4gICAgICogY29udHJvbC4gSXQgd2lsbCBiZSB1c2VkIHdoZW4gY2FsbGluZ1xyXG4gICAgICogW1NlcnZpY2VXb3JrZXJDb250YWluZXIjcmVnaXN0ZXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VXb3JrZXJDb250YWluZXIvcmVnaXN0ZXIpLlxyXG4gICAgICovXHJcbiAgICBzY29wZT86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB0aGUgU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gc3RyYXRlZ3ksIHdoaWNoIGRldGVybWluZXMgd2hlbiBpdCB3aWxsIGJlIHJlZ2lzdGVyZWRcclxuICAgICAqIHdpdGggdGhlIGJyb3dzZXIuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgcmVnaXN0ZXJpbmcgb25jZSB0aGUgYXBwbGljYXRpb24gc3RhYmlsaXplcyAoaS5lLiBhcyBzb29uIGFzIHRoZXJlIGFyZVxyXG4gICAgICogbm8gcGVuZGluZyBtaWNyby0gYW5kIG1hY3JvLXRhc2tzKSwgaXMgZGVzaWduZWQgcmVnaXN0ZXIgdGhlIFNlcnZpY2VXb3JrZXIgYXMgc29vbiBhcyBwb3NzaWJsZVxyXG4gICAgICogYnV0IHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBhcHBsaWNhdGlvbidzIGZpcnN0IHRpbWUgbG9hZC5cclxuICAgICAqXHJcbiAgICAgKiBTdGlsbCwgdGhlcmUgbWlnaHQgYmUgY2FzZXMgd2hlcmUgeW91IHdhbnQgbW9yZSBjb250cm9sIG92ZXIgd2hlbiB0aGUgU2VydmljZVdvcmtlciBpc1xyXG4gICAgICogcmVnaXN0ZXJlZCAoZS5nLiB0aGVyZSBtaWdodCBiZSBhIGxvbmctcnVubmluZyB0aW1lb3V0IG9yIHBvbGxpbmcgaW50ZXJ2YWwsIHByZXZlbnRpbmcgdGhlIGFwcFxyXG4gICAgICogdG8gc3RhYmlsaXplKS4gVGhlIGF2YWlsYWJsZSBvcHRpb24gYXJlOlxyXG4gICAgICpcclxuICAgICAqIC0gYHJlZ2lzdGVyV2hlblN0YWJsZWA6IFJlZ2lzdGVyIGFzIHNvb24gYXMgdGhlIGFwcGxpY2F0aW9uIHN0YWJpbGl6ZXMgKG5vIHBlbmRpbmdcclxuICAgICAqICAgICAgbWljcm8tL21hY3JvLXRhc2tzKS5cclxuICAgICAqIC0gYHJlZ2lzdGVySW1tZWRpYXRlbHlgOiBSZWdpc3RlciBpbW1lZGlhdGVseS5cclxuICAgICAqIC0gYHJlZ2lzdGVyV2l0aERlbGF5Ojx0aW1lb3V0PmA6IFJlZ2lzdGVyIHdpdGggYSBkZWxheSBvZiBgPHRpbWVvdXQ+YCBtaWxsaXNlY29uZHMuIEZvclxyXG4gICAgICogICAgIGV4YW1wbGUsIHVzZSBgcmVnaXN0ZXJXaXRoRGVsYXk6NTAwMGAgdG8gcmVnaXN0ZXIgdGhlIFNlcnZpY2VXb3JrZXIgYWZ0ZXIgNSBzZWNvbmRzLiBJZlxyXG4gICAgICogICAgIGA8dGltZW91dD5gIGlzIG9taXR0ZWQsIGlzIGRlZmF1bHRzIHRvIGAwYCwgd2hpY2ggd2lsbCByZWdpc3RlciB0aGUgU2VydmljZVdvcmtlciBhcyBzb29uXHJcbiAgICAgKiAgICAgYXMgcG9zc2libGUgYnV0IHN0aWxsIGFzeW5jaHJvbm91c2x5LCBvbmNlIGFsbCBwZW5kaW5nIG1pY3JvLXRhc2tzIGFyZSBjb21wbGV0ZWQuXHJcbiAgICAgKiAtIEFuIFtPYnNlcnZhYmxlXShndWlkZS9vYnNlcnZhYmxlcykgZmFjdG9yeSBmdW5jdGlvbjogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYE9ic2VydmFibGVgLlxyXG4gICAgICogICAgIFRoZSBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgYXQgcnVudGltZSB0byBvYnRhaW4gYW5kIHN1YnNjcmliZSB0byB0aGUgYE9ic2VydmFibGVgIGFuZCB0aGVcclxuICAgICAqICAgICBTZXJ2aWNlV29ya2VyIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBzb29uIGFzIHRoZSBmaXJzdCB2YWx1ZSBpcyBlbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQ6ICdyZWdpc3RlcldoZW5TdGFibGUnXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdHJhdGlvblN0cmF0ZWd5Pzogc3RyaW5nIHwgKCgpID0+IE9ic2VydmFibGU8dW5rbm93bj4pO1xyXG59XHJcblxyXG4vKipcclxuICogU3Vic2NyaWJlIHRvIHVwZGF0ZSBub3RpZmljYXRpb25zIGZyb20gdGhlIFNlcnZpY2UgV29ya2VyLCB0cmlnZ2VyIHVwZGF0ZVxyXG4gKiBjaGVja3MsIGFuZCBmb3JjaWJseSBhY3RpdmF0ZSB1cGRhdGVzLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBTd1VwZGF0ZSB7XHJcbiAgICBwcml2YXRlIHN3O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBgVXBkYXRlQXZhaWxhYmxlRXZlbnRgIGV2ZW50IHdoZW5ldmVyIGEgbmV3IGFwcCB2ZXJzaW9uIGlzIGF2YWlsYWJsZS5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgYXZhaWxhYmxlOiBPYnNlcnZhYmxlPFVwZGF0ZUF2YWlsYWJsZUV2ZW50PjtcclxuICAgIC8qKlxyXG4gICAgICogRW1pdHMgYW4gYFVwZGF0ZUFjdGl2YXRlZEV2ZW50YCBldmVudCB3aGVuZXZlciB0aGUgYXBwIGhhcyBiZWVuIHVwZGF0ZWQgdG8gYSBuZXcgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgYWN0aXZhdGVkOiBPYnNlcnZhYmxlPFVwZGF0ZUFjdGl2YXRlZEV2ZW50PjtcclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgU2VydmljZSBXb3JrZXIgaXMgZW5hYmxlZCAoc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIGFuZCBlbmFibGVkIHZpYVxyXG4gICAgICogYFNlcnZpY2VXb3JrZXJNb2R1bGVgKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3Ioc3c6IMm1YW5ndWxhcl9wYWNrYWdlc19zZXJ2aWNlX3dvcmtlcl9zZXJ2aWNlX3dvcmtlcl9hKTtcclxuICAgIGNoZWNrRm9yVXBkYXRlKCk6IFByb21pc2U8dm9pZD47XHJcbiAgICBhY3RpdmF0ZVVwZGF0ZSgpOiBQcm9taXNlPHZvaWQ+O1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBUeXBlZEV2ZW50IHtcclxuICAgIHR5cGU6IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBhcHAgaGFzIGJlZW4gZG93bmxvYWRlZCBhbmQgYWN0aXZhdGVkLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgVXBkYXRlQWN0aXZhdGVkRXZlbnQge1xyXG4gICAgdHlwZTogJ1VQREFURV9BQ1RJVkFURUQnO1xyXG4gICAgcHJldmlvdXM/OiB7XHJcbiAgICAgICAgaGFzaDogc3RyaW5nO1xyXG4gICAgICAgIGFwcERhdGE/OiBPYmplY3Q7XHJcbiAgICB9O1xyXG4gICAgY3VycmVudDoge1xyXG4gICAgICAgIGhhc2g6IHN0cmluZztcclxuICAgICAgICBhcHBEYXRhPzogT2JqZWN0O1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBhcHAgaXMgYXZhaWxhYmxlLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgVXBkYXRlQXZhaWxhYmxlRXZlbnQge1xyXG4gICAgdHlwZTogJ1VQREFURV9BVkFJTEFCTEUnO1xyXG4gICAgY3VycmVudDoge1xyXG4gICAgICAgIGhhc2g6IHN0cmluZztcclxuICAgICAgICBhcHBEYXRhPzogT2JqZWN0O1xyXG4gICAgfTtcclxuICAgIGF2YWlsYWJsZToge1xyXG4gICAgICAgIGhhc2g6IHN0cmluZztcclxuICAgICAgICBhcHBEYXRhPzogT2JqZWN0O1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIMm1YW5ndWxhcl9wYWNrYWdlc19zZXJ2aWNlX3dvcmtlcl9zZXJ2aWNlX3dvcmtlcl9hIHtcclxuICAgIHByaXZhdGUgc2VydmljZVdvcmtlcjtcclxuICAgIHJlYWRvbmx5IHdvcmtlcjogT2JzZXJ2YWJsZTxTZXJ2aWNlV29ya2VyPjtcclxuICAgIHJlYWRvbmx5IHJlZ2lzdHJhdGlvbjogT2JzZXJ2YWJsZTxTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uPjtcclxuICAgIHJlYWRvbmx5IGV2ZW50czogT2JzZXJ2YWJsZTxUeXBlZEV2ZW50PjtcclxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VXb3JrZXI6IFNlcnZpY2VXb3JrZXJDb250YWluZXIgfCB1bmRlZmluZWQpO1xyXG4gICAgcG9zdE1lc3NhZ2UoYWN0aW9uOiBzdHJpbmcsIHBheWxvYWQ6IE9iamVjdCk6IFByb21pc2U8dm9pZD47XHJcbiAgICBwb3N0TWVzc2FnZVdpdGhTdGF0dXModHlwZTogc3RyaW5nLCBwYXlsb2FkOiBPYmplY3QsIG5vbmNlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgZ2VuZXJhdGVOb25jZSgpOiBudW1iZXI7XHJcbiAgICBldmVudHNPZlR5cGU8VCBleHRlbmRzIFR5cGVkRXZlbnQ+KHR5cGU6IFRbJ3R5cGUnXSk6IE9ic2VydmFibGU8VD47XHJcbiAgICBuZXh0RXZlbnRPZlR5cGU8VCBleHRlbmRzIFR5cGVkRXZlbnQ+KHR5cGU6IFRbJ3R5cGUnXSk6IE9ic2VydmFibGU8VD47XHJcbiAgICB3YWl0Rm9yU3RhdHVzKG5vbmNlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgZGVjbGFyZSBjb25zdCDJtWFuZ3VsYXJfcGFja2FnZXNfc2VydmljZV93b3JrZXJfc2VydmljZV93b3JrZXJfYjogSW5qZWN0aW9uVG9rZW48c3RyaW5nPjtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIMm1YW5ndWxhcl9wYWNrYWdlc19zZXJ2aWNlX3dvcmtlcl9zZXJ2aWNlX3dvcmtlcl9jKGluamVjdG9yOiBJbmplY3Rvciwgc2NyaXB0OiBzdHJpbmcsIG9wdGlvbnM6IFN3UmVnaXN0cmF0aW9uT3B0aW9ucywgcGxhdGZvcm1JZDogc3RyaW5nKTogRnVuY3Rpb247XHJcblxyXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiDJtWFuZ3VsYXJfcGFja2FnZXNfc2VydmljZV93b3JrZXJfc2VydmljZV93b3JrZXJfZChvcHRzOiBTd1JlZ2lzdHJhdGlvbk9wdGlvbnMsIHBsYXRmb3JtSWQ6IHN0cmluZyk6IMm1YW5ndWxhcl9wYWNrYWdlc19zZXJ2aWNlX3dvcmtlcl9zZXJ2aWNlX3dvcmtlcl9hO1xyXG5cclxuZXhwb3J0IHsgfVxyXG4iXX0=